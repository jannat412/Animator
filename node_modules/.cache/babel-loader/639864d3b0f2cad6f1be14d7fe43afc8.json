{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // misc\n\nvar index_1 = require(\"../../misc/index\"); // Layers\n\n\nvar index_2 = __importDefault(require(\"../../path/index\")); // Logging\n\n\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\n\nvar getValueFromRange = function (values, numOfKeyPaths, index) {\n  var min = Math.min.apply(Math, values);\n  var max = Math.max.apply(Math, values);\n  return (max - min) / numOfKeyPaths * index + min;\n};\n\nvar generateDValues = function (data) {\n  log.info(\"start generate d values\");\n  var _a = data.parameters,\n      numOfKeyPaths = _a.numOfKeyPaths,\n      loop = _a.loop;\n  var inputKeyPathsParameters = data.keyPathsParameters; // Maybe need to refactor\n\n  var paths = [];\n  var dValuesFrames = [];\n\n  for (var i = 0; i < numOfKeyPaths; i++) {\n    log.info(\"generate key path number \" + i);\n    var pathParameters = {};\n\n    for (var key in inputKeyPathsParameters) {\n      // Set parameters for 'i' key path\n      if (key === \"groups\") {\n        if (index_1.getType(inputKeyPathsParameters[key][0]) === \"object\") // One setup for all key paths groups\n          pathParameters[key] = inputKeyPathsParameters[key];else pathParameters[key] = inputKeyPathsParameters[key][i];\n        log.debug(\"group param\", pathParameters[key]);\n      } else if (typeof inputKeyPathsParameters[key] !== \"object\") {\n        // if one value for all paths\n        pathParameters[key] = inputKeyPathsParameters[key];\n      } else {\n        if (inputKeyPathsParameters[key].length === numOfKeyPaths) // if individual values for each path\n          pathParameters[key] = inputKeyPathsParameters[key][i];else if (inputKeyPathsParameters[key].length === 2) // calculate value from [min number, max number] range\n          pathParameters[key] = getValueFromRange(inputKeyPathsParameters[key], numOfKeyPaths, i);else throw \"Wrong '\" + key + \"' parameter array at \" + i + \" key path\";\n      }\n    }\n\n    var path = index_2.default(pathParameters);\n    paths[i] = path;\n    dValuesFrames[i] = path.d;\n\n    if (loop) {\n      if (loop === \"linear\" && i !== numOfKeyPaths - 1) {\n        // Linear or boomerang loop\n        dValuesFrames[(numOfKeyPaths - 1) * 2 - i] = path.d;\n      } else if (loop === \"circle\" && i === numOfKeyPaths - 1) {\n        // Circle loop. Last path equal to first\n        dValuesFrames[numOfKeyPaths] = dValuesFrames[0];\n      }\n    }\n  }\n\n  var dValues = dValuesFrames.join(\";\");\n  return __assign({}, data, {\n    dValues: dValues,\n    dValuesFrames: dValuesFrames\n  });\n};\n\nexports.default = generateDValues;","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/morphing/lib/generateDValues.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__importDefault","mod","__esModule","defineProperty","exports","value","index_1","require","index_2","log","getLogger","getValueFromRange","values","numOfKeyPaths","index","min","Math","max","generateDValues","data","info","_a","parameters","loop","inputKeyPathsParameters","keyPathsParameters","paths","dValuesFrames","pathParameters","key","getType","debug","path","default","d","dValues","join"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// misc\nvar index_1 = require(\"../../misc/index\");\n// Layers\nvar index_2 = __importDefault(require(\"../../path/index\"));\n// Logging\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\nvar getValueFromRange = function (values, numOfKeyPaths, index) {\n    var min = Math.min.apply(Math, values);\n    var max = Math.max.apply(Math, values);\n    return ((max - min) / numOfKeyPaths) * index + min;\n};\nvar generateDValues = function (data) {\n    log.info(\"start generate d values\");\n    var _a = data.parameters, numOfKeyPaths = _a.numOfKeyPaths, loop = _a.loop;\n    var inputKeyPathsParameters = data.keyPathsParameters; // Maybe need to refactor\n    var paths = [];\n    var dValuesFrames = [];\n    for (var i = 0; i < numOfKeyPaths; i++) {\n        log.info(\"generate key path number \" + i);\n        var pathParameters = {};\n        for (var key in inputKeyPathsParameters) {\n            // Set parameters for 'i' key path\n            if (key === \"groups\") {\n                if (index_1.getType(inputKeyPathsParameters[key][0]) === \"object\")\n                    // One setup for all key paths groups\n                    pathParameters[key] = inputKeyPathsParameters[key];\n                else\n                    pathParameters[key] = inputKeyPathsParameters[key][i];\n                log.debug(\"group param\", pathParameters[key]);\n            }\n            else if (typeof inputKeyPathsParameters[key] !== \"object\") {\n                // if one value for all paths\n                pathParameters[key] = inputKeyPathsParameters[key];\n            }\n            else {\n                if (inputKeyPathsParameters[key].length === numOfKeyPaths)\n                    // if individual values for each path\n                    pathParameters[key] = inputKeyPathsParameters[key][i];\n                else if (inputKeyPathsParameters[key].length === 2)\n                    // calculate value from [min number, max number] range\n                    pathParameters[key] = getValueFromRange(inputKeyPathsParameters[key], numOfKeyPaths, i);\n                else\n                    throw \"Wrong '\" + key + \"' parameter array at \" + i + \" key path\";\n            }\n        }\n        var path = index_2.default(pathParameters);\n        paths[i] = path;\n        dValuesFrames[i] = path.d;\n        if (loop) {\n            if (loop === \"linear\" && i !== numOfKeyPaths - 1) {\n                // Linear or boomerang loop\n                dValuesFrames[(numOfKeyPaths - 1) * 2 - i] = path.d;\n            }\n            else if (loop === \"circle\" && i === numOfKeyPaths - 1) {\n                // Circle loop. Last path equal to first\n                dValuesFrames[numOfKeyPaths] = dValuesFrames[0];\n            }\n        }\n    }\n    var dValues = dValuesFrames.join(\";\");\n    return __assign({}, data, { dValues: dValues, dValuesFrames: dValuesFrames });\n};\nexports.default = generateDValues;\n"]},"metadata":{},"sourceType":"script"}