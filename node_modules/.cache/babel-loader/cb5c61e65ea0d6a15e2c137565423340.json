{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\n\nvar phaseOneRatio = 2;\nvar phaseTwoRatio = 2;\nvar baseParameters = {\n  numOfSegments: 4,\n  x: 0,\n  y: 0,\n  width: 1920,\n  height: 937,\n  centerX: 1820,\n  centerY: 100,\n  rotate: 45\n};\nvar startGroupsParameters = [{\n  incircle: false,\n  radius: 2,\n  round: 1,\n  adaptArms: true,\n  smartRound: true\n}, {\n  incircle: false,\n  type: \"linear\",\n  radius: 2,\n  round: 1,\n  adaptArms: true,\n  smartRound: true\n}];\nvar endGroupsParameters = [{\n  incircle: false,\n  distance: 1,\n  round: 0,\n  adaptArms: true,\n  lengthBasedRound: true\n}, {\n  incircle: false,\n  type: \"linear\",\n  distance: 1,\n  round: 1,\n  adaptArms: false,\n  lengthBasedRound: true\n}]; ///////////////\n// Phase one //\n///////////////\n\nvar progressionsPhaseScope = function (params) {\n  var numOfVertexes = params.endPath.vertexes.length;\n  var progressions = Array(numOfVertexes);\n  progressions.fill(1, 0, numOfVertexes);\n  return progressions;\n};\n\nvar progressionsGeneralScope = function (params) {\n  var numOfVertexes = params.endPath.vertexes.length;\n  var progressions = Array(numOfVertexes);\n  progressions.fill(params.duration, 0, numOfVertexes);\n  return progressions;\n};\n\nvar phaseOneDuration = function (_a) {\n  var endPath = _a.endPath;\n  var _b = endPath.parameters,\n      minLength = _b.minLength,\n      maxLength = _b.maxLength; // if (minLength < 200) minLength = 200;\n\n  var duration = minLength / phaseOneRatio;\n  duration = 0.5 / (maxLength / duration);\n  return duration;\n};\n\nvar phaseOneRadius = function (_a) {\n  var endPath = _a.endPath,\n      progression = _a.progression;\n  var maxLength = endPath.parameters.maxLength;\n  return maxLength * progression;\n};\n\nvar phaseOne = {\n  duration: phaseOneDuration,\n  progressionsPhaseScope: progressionsPhaseScope,\n  progressionsGeneralScope: progressionsGeneralScope,\n  groupsParameters: [{\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"radial\";\n    },\n    radius: phaseOneRadius,\n    round: function () {\n      return 1;\n    },\n    adaptArms: function () {\n      return true;\n    },\n    smartRound: function () {\n      return true;\n    }\n  }, {\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"linear\";\n    },\n    radius: phaseOneRadius,\n    round: function () {\n      return 1;\n    },\n    adaptArms: function () {\n      return true;\n    },\n    smartRound: function () {\n      return true;\n    }\n  }]\n}; ///////////////\n// Phase two //\n///////////////\n\nvar duration = function (_a) {\n  var prevDurations = _a.prevDurations;\n  return 0.5 - prevDurations[0];\n};\n\nvar progressionsPhaseScope = function (params) {\n  var progressions = [];\n  var endPath = params.endPath,\n      duration = params.duration;\n  params.endPath.vertexes.forEach(function (vertex, index) {\n    var maxLength = endPath.parameters.maxLength;\n    var delta = maxLength / vertex.length;\n    progressions.push(1 / delta);\n  });\n  return progressions;\n};\n\nvar progressionsGeneralScope = function (params) {\n  var duration = params.duration,\n      endPath = params.endPath,\n      prevPhaseProgressions = params.prevPhaseProgressions;\n  var progressions = [];\n  params.endPath.vertexes.forEach(function (vertex, index) {\n    var maxLength = endPath.parameters.maxLength;\n    var delta = maxLength / vertex.length;\n    progressions.push(duration / delta + prevPhaseProgressions[index]);\n  });\n  return progressions;\n};\n\nvar radiusFirstGroup = function (_a) {\n  var progression = _a.progression,\n      endPath = _a.endPath,\n      vertex = _a.vertex,\n      progressionsGeneralScope = _a.progressionsGeneralScope,\n      progressionsPhaseScope = _a.progressionsPhaseScope,\n      activePhaseIndex = _a.activePhaseIndex,\n      phasesDuration = _a.phasesDuration;\n  var maxLength = endPath.parameters.maxLength;\n  var factor = progression / progressionsGeneralScope[activePhaseIndex][vertex.index] * progressionsPhaseScope[activePhaseIndex][vertex.index];\n  var result = factor * maxLength;\n  return result;\n};\n\nvar radiusSecondGroup = function (_a) {\n  var progression = _a.progression,\n      endPath = _a.endPath,\n      vertex = _a.vertex,\n      progressionsGeneralScope = _a.progressionsGeneralScope,\n      progressionsPhaseScope = _a.progressionsPhaseScope,\n      activePhaseIndex = _a.activePhaseIndex,\n      phasesDuration = _a.phasesDuration;\n  var maxLength = endPath.parameters.maxLength;\n  var factor = progression / progressionsGeneralScope[activePhaseIndex][vertex.index] * progressionsPhaseScope[activePhaseIndex][vertex.index];\n  var result = factor * maxLength;\n  return result / 2;\n};\n\nvar phaseTwo = {\n  duration: duration,\n  progressionsPhaseScope: progressionsPhaseScope,\n  progressionsGeneralScope: progressionsGeneralScope,\n  groupsParameters: [{\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"radial\";\n    },\n    radius: radiusFirstGroup,\n    adaptArms: function () {\n      return true;\n    },\n    round: function () {\n      return 1;\n    },\n    lengthBasedRound: function () {\n      return true;\n    }\n  }, {\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"linear\";\n    },\n    radius: radiusSecondGroup,\n    adaptArms: function () {\n      return false;\n    },\n    round: function () {\n      return 1;\n    },\n    lengthBasedRound: function () {\n      return true;\n    }\n  }]\n}; /////////////////\n// Phase three //\n/////////////////\n\nvar progressionsPhaseScope = function (params) {\n  var progressions = [];\n  var endPath = params.endPath,\n      duration = params.duration;\n  var vertexes = endPath.vertexes;\n  var maxLength = endPath.parameters.maxLengthByGroup[1];\n\n  for (var i = 0; i < vertexes.length; i++) {\n    var vertex = vertexes[i];\n\n    if (vertex.group === 0) {\n      // Handle M and C type vertexes\n      var prevIndex = i === 0 ? vertexes.length - 2 : i - 1;\n      var nextIndex = i === vertexes.length - 1 ? 1 : i + 1;\n      var prevDelta = maxLength / vertexes[prevIndex].length;\n      var nextDelta = maxLength / vertexes[nextIndex].length;\n      var prevProgression = 1 / prevDelta;\n      var nextProgression = 1 / nextDelta;\n      progressions[prevIndex] = prevProgression;\n      progressions[nextIndex] = nextProgression;\n      progressions[i] = nextProgression > prevProgression ? nextProgression : prevProgression;\n    } else if (progressions[i] === undefined) {\n      var delta = maxLength / vertex.length;\n      progressions[i] = 1 / delta;\n    }\n  }\n\n  return progressions;\n};\n\nvar progressionsGeneralScope = function (params) {\n  var duration = params.duration,\n      endPath = params.endPath,\n      prevPhaseProgressions = params.prevPhaseProgressions;\n  var vertexes = endPath.vertexes;\n  var maxLength = endPath.parameters.maxLengthByGroup[1];\n  var progressions = [];\n\n  for (var i = 0; i < vertexes.length; i++) {\n    var vertex = vertexes[i];\n\n    if (vertex.group === 0) {\n      // Handle M and C type vertexes\n      var prevIndex = i === 0 ? vertexes.length - 2 : i - 1;\n      var nextIndex = i === vertexes.length - 1 ? 1 : i + 1;\n      var prevDelta = maxLength / vertexes[prevIndex].length;\n      var nextDelta = maxLength / vertexes[nextIndex].length;\n      var prevProgression = duration / prevDelta + prevPhaseProgressions[prevIndex];\n      var nextProgression = duration / nextDelta + prevPhaseProgressions[nextIndex];\n      progressions[prevIndex] = prevProgression;\n      progressions[nextIndex] = nextProgression;\n      progressions[i] = nextProgression > prevProgression ? nextProgression : prevProgression;\n    } else if (progressions[i] === undefined) {\n      var delta = maxLength / vertex.length;\n      progressions[i] = duration / delta + prevPhaseProgressions[i];\n    }\n  }\n\n  return progressions;\n};\n\nvar roundFirstGroup = function (_a) {\n  var progression = _a.progression,\n      endPath = _a.endPath,\n      vertex = _a.vertex,\n      progressionsGeneralScope = _a.progressionsGeneralScope,\n      progressionsPhaseScope = _a.progressionsPhaseScope,\n      activePhaseIndex = _a.activePhaseIndex;\n  var vertexes = endPath.vertexes;\n  var prevIndex = vertex.index === 0 ? vertexes.length - 2 : vertex.index - 1;\n  var nextIndex = vertex.index === vertexes.length - 1 ? 1 : vertex.index + 1;\n  var firstFactor = progression / progressionsGeneralScope[activePhaseIndex][prevIndex];\n  var firstArm = 1 - firstFactor;\n  if (firstArm < 0) firstArm = 0;\n  var secondFactor = progression / progressionsGeneralScope[activePhaseIndex][nextIndex];\n  var secondArm = 1 - secondFactor;\n  if (secondArm < 0) secondArm = 0;\n  var result = [firstArm, secondArm];\n  return result;\n};\n\nvar radiusSecondGroup = function (_a) {\n  var progression = _a.progression,\n      endPath = _a.endPath,\n      vertex = _a.vertex,\n      progressionsGeneralScope = _a.progressionsGeneralScope,\n      progressionsPhaseScope = _a.progressionsPhaseScope,\n      activePhaseIndex = _a.activePhaseIndex;\n  var maxLength = endPath.parameters.maxLengthByGroup[1];\n  var factor = progression / progressionsGeneralScope[activePhaseIndex][vertex.index] * progressionsPhaseScope[activePhaseIndex][vertex.index];\n  var result = factor * maxLength;\n  return result;\n};\n\nvar phaseThree = {\n  duration: function () {\n    return 0.5;\n  },\n  progressionsPhaseScope: progressionsPhaseScope,\n  progressionsGeneralScope: progressionsGeneralScope,\n  groupsParameters: [{\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"radial\";\n    },\n    radius: function (_a) {\n      var vertex = _a.vertex;\n      return vertex.length;\n    },\n    adaptArms: function () {\n      return true;\n    },\n    round: roundFirstGroup,\n    lengthBasedRound: function () {\n      return true;\n    }\n  }, {\n    incircle: function () {\n      return false;\n    },\n    type: function () {\n      return \"linear\";\n    },\n    radius: radiusSecondGroup,\n    adaptArms: function () {\n      return false;\n    },\n    round: function () {\n      return 1;\n    },\n    lengthBasedRound: function () {\n      return true;\n    }\n  }]\n};\nexports.default = {\n  loop: undefined,\n  startGroupsParameters: startGroupsParameters,\n  endGroupsParameters: endGroupsParameters,\n  baseParameters: baseParameters,\n  phases: [__assign({}, phaseOne), __assign({}, phaseTwo), __assign({}, phaseThree)]\n};","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/phases/defaultParameters.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","defineProperty","exports","value","log","require","getLogger","phaseOneRatio","phaseTwoRatio","baseParameters","numOfSegments","x","y","width","height","centerX","centerY","rotate","startGroupsParameters","incircle","radius","round","adaptArms","smartRound","type","endGroupsParameters","distance","lengthBasedRound","progressionsPhaseScope","params","numOfVertexes","endPath","vertexes","progressions","Array","fill","progressionsGeneralScope","duration","phaseOneDuration","_a","_b","parameters","minLength","maxLength","phaseOneRadius","progression","phaseOne","groupsParameters","prevDurations","forEach","vertex","index","delta","push","prevPhaseProgressions","radiusFirstGroup","activePhaseIndex","phasesDuration","factor","result","radiusSecondGroup","phaseTwo","maxLengthByGroup","group","prevIndex","nextIndex","prevDelta","nextDelta","prevProgression","nextProgression","undefined","roundFirstGroup","firstFactor","firstArm","secondFactor","secondArm","phaseThree","default","loop","phases"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\nvar phaseOneRatio = 2;\nvar phaseTwoRatio = 2;\nvar baseParameters = {\n    numOfSegments: 4,\n    x: 0,\n    y: 0,\n    width: 1920,\n    height: 937,\n    centerX: 1820,\n    centerY: 100,\n    rotate: 45\n};\nvar startGroupsParameters = [\n    {\n        incircle: false,\n        radius: 2,\n        round: 1,\n        adaptArms: true,\n        smartRound: true\n    },\n    {\n        incircle: false,\n        type: \"linear\",\n        radius: 2,\n        round: 1,\n        adaptArms: true,\n        smartRound: true\n    }\n];\nvar endGroupsParameters = [\n    {\n        incircle: false,\n        distance: 1,\n        round: 0,\n        adaptArms: true,\n        lengthBasedRound: true\n    },\n    {\n        incircle: false,\n        type: \"linear\",\n        distance: 1,\n        round: 1,\n        adaptArms: false,\n        lengthBasedRound: true\n    }\n];\n///////////////\n// Phase one //\n///////////////\nvar progressionsPhaseScope = function (params) {\n    var numOfVertexes = params.endPath.vertexes.length;\n    var progressions = Array(numOfVertexes);\n    progressions.fill(1, 0, numOfVertexes);\n    return progressions;\n};\nvar progressionsGeneralScope = function (params) {\n    var numOfVertexes = params.endPath.vertexes.length;\n    var progressions = Array(numOfVertexes);\n    progressions.fill(params.duration, 0, numOfVertexes);\n    return progressions;\n};\nvar phaseOneDuration = function (_a) {\n    var endPath = _a.endPath;\n    var _b = endPath.parameters, minLength = _b.minLength, maxLength = _b.maxLength;\n    // if (minLength < 200) minLength = 200;\n    var duration = minLength / phaseOneRatio;\n    duration = 0.5 / (maxLength / duration);\n    return duration;\n};\nvar phaseOneRadius = function (_a) {\n    var endPath = _a.endPath, progression = _a.progression;\n    var maxLength = endPath.parameters.maxLength;\n    return maxLength * progression;\n};\nvar phaseOne = {\n    duration: phaseOneDuration,\n    progressionsPhaseScope: progressionsPhaseScope,\n    progressionsGeneralScope: progressionsGeneralScope,\n    groupsParameters: [\n        {\n            incircle: function () { return false; },\n            type: function () { return \"radial\"; },\n            radius: phaseOneRadius,\n            round: function () { return 1; },\n            adaptArms: function () { return true; },\n            smartRound: function () { return true; }\n        },\n        {\n            incircle: function () { return false; },\n            type: function () { return \"linear\"; },\n            radius: phaseOneRadius,\n            round: function () { return 1; },\n            adaptArms: function () { return true; },\n            smartRound: function () { return true; }\n        }\n    ]\n};\n///////////////\n// Phase two //\n///////////////\nvar duration = function (_a) {\n    var prevDurations = _a.prevDurations;\n    return 0.5 - prevDurations[0];\n};\nvar progressionsPhaseScope = function (params) {\n    var progressions = [];\n    var endPath = params.endPath, duration = params.duration;\n    params.endPath.vertexes.forEach(function (vertex, index) {\n        var maxLength = endPath.parameters.maxLength;\n        var delta = maxLength / vertex.length;\n        progressions.push(1 / delta);\n    });\n    return progressions;\n};\nvar progressionsGeneralScope = function (params) {\n    var duration = params.duration, endPath = params.endPath, prevPhaseProgressions = params.prevPhaseProgressions;\n    var progressions = [];\n    params.endPath.vertexes.forEach(function (vertex, index) {\n        var maxLength = endPath.parameters.maxLength;\n        var delta = maxLength / vertex.length;\n        progressions.push(duration / delta + prevPhaseProgressions[index]);\n    });\n    return progressions;\n};\nvar radiusFirstGroup = function (_a) {\n    var progression = _a.progression, endPath = _a.endPath, vertex = _a.vertex, progressionsGeneralScope = _a.progressionsGeneralScope, progressionsPhaseScope = _a.progressionsPhaseScope, activePhaseIndex = _a.activePhaseIndex, phasesDuration = _a.phasesDuration;\n    var maxLength = endPath.parameters.maxLength;\n    var factor = (progression / progressionsGeneralScope[activePhaseIndex][vertex.index]) *\n        progressionsPhaseScope[activePhaseIndex][vertex.index];\n    var result = factor * maxLength;\n    return result;\n};\nvar radiusSecondGroup = function (_a) {\n    var progression = _a.progression, endPath = _a.endPath, vertex = _a.vertex, progressionsGeneralScope = _a.progressionsGeneralScope, progressionsPhaseScope = _a.progressionsPhaseScope, activePhaseIndex = _a.activePhaseIndex, phasesDuration = _a.phasesDuration;\n    var maxLength = endPath.parameters.maxLength;\n    var factor = (progression / progressionsGeneralScope[activePhaseIndex][vertex.index]) *\n        progressionsPhaseScope[activePhaseIndex][vertex.index];\n    var result = factor * maxLength;\n    return result / 2;\n};\nvar phaseTwo = {\n    duration: duration,\n    progressionsPhaseScope: progressionsPhaseScope,\n    progressionsGeneralScope: progressionsGeneralScope,\n    groupsParameters: [\n        {\n            incircle: function () { return false; },\n            type: function () { return \"radial\"; },\n            radius: radiusFirstGroup,\n            adaptArms: function () { return true; },\n            round: function () { return 1; },\n            lengthBasedRound: function () { return true; }\n        },\n        {\n            incircle: function () { return false; },\n            type: function () { return \"linear\"; },\n            radius: radiusSecondGroup,\n            adaptArms: function () { return false; },\n            round: function () { return 1; },\n            lengthBasedRound: function () { return true; }\n        }\n    ]\n};\n/////////////////\n// Phase three //\n/////////////////\nvar progressionsPhaseScope = function (params) {\n    var progressions = [];\n    var endPath = params.endPath, duration = params.duration;\n    var vertexes = endPath.vertexes;\n    var maxLength = endPath.parameters.maxLengthByGroup[1];\n    for (var i = 0; i < vertexes.length; i++) {\n        var vertex = vertexes[i];\n        if (vertex.group === 0) {\n            // Handle M and C type vertexes\n            var prevIndex = i === 0 ? vertexes.length - 2 : i - 1;\n            var nextIndex = i === vertexes.length - 1 ? 1 : i + 1;\n            var prevDelta = maxLength / vertexes[prevIndex].length;\n            var nextDelta = maxLength / vertexes[nextIndex].length;\n            var prevProgression = 1 / prevDelta;\n            var nextProgression = 1 / nextDelta;\n            progressions[prevIndex] = prevProgression;\n            progressions[nextIndex] = nextProgression;\n            progressions[i] =\n                nextProgression > prevProgression ? nextProgression : prevProgression;\n        }\n        else if (progressions[i] === undefined) {\n            var delta = maxLength / vertex.length;\n            progressions[i] = 1 / delta;\n        }\n    }\n    return progressions;\n};\nvar progressionsGeneralScope = function (params) {\n    var duration = params.duration, endPath = params.endPath, prevPhaseProgressions = params.prevPhaseProgressions;\n    var vertexes = endPath.vertexes;\n    var maxLength = endPath.parameters.maxLengthByGroup[1];\n    var progressions = [];\n    for (var i = 0; i < vertexes.length; i++) {\n        var vertex = vertexes[i];\n        if (vertex.group === 0) {\n            // Handle M and C type vertexes\n            var prevIndex = i === 0 ? vertexes.length - 2 : i - 1;\n            var nextIndex = i === vertexes.length - 1 ? 1 : i + 1;\n            var prevDelta = maxLength / vertexes[prevIndex].length;\n            var nextDelta = maxLength / vertexes[nextIndex].length;\n            var prevProgression = duration / prevDelta + prevPhaseProgressions[prevIndex];\n            var nextProgression = duration / nextDelta + prevPhaseProgressions[nextIndex];\n            progressions[prevIndex] = prevProgression;\n            progressions[nextIndex] = nextProgression;\n            progressions[i] =\n                nextProgression > prevProgression ? nextProgression : prevProgression;\n        }\n        else if (progressions[i] === undefined) {\n            var delta = maxLength / vertex.length;\n            progressions[i] = duration / delta + prevPhaseProgressions[i];\n        }\n    }\n    return progressions;\n};\nvar roundFirstGroup = function (_a) {\n    var progression = _a.progression, endPath = _a.endPath, vertex = _a.vertex, progressionsGeneralScope = _a.progressionsGeneralScope, progressionsPhaseScope = _a.progressionsPhaseScope, activePhaseIndex = _a.activePhaseIndex;\n    var vertexes = endPath.vertexes;\n    var prevIndex = vertex.index === 0 ? vertexes.length - 2 : vertex.index - 1;\n    var nextIndex = vertex.index === vertexes.length - 1 ? 1 : vertex.index + 1;\n    var firstFactor = progression / progressionsGeneralScope[activePhaseIndex][prevIndex];\n    var firstArm = 1 - firstFactor;\n    if (firstArm < 0)\n        firstArm = 0;\n    var secondFactor = progression / progressionsGeneralScope[activePhaseIndex][nextIndex];\n    var secondArm = 1 - secondFactor;\n    if (secondArm < 0)\n        secondArm = 0;\n    var result = [firstArm, secondArm];\n    return result;\n};\nvar radiusSecondGroup = function (_a) {\n    var progression = _a.progression, endPath = _a.endPath, vertex = _a.vertex, progressionsGeneralScope = _a.progressionsGeneralScope, progressionsPhaseScope = _a.progressionsPhaseScope, activePhaseIndex = _a.activePhaseIndex;\n    var maxLength = endPath.parameters.maxLengthByGroup[1];\n    var factor = (progression / progressionsGeneralScope[activePhaseIndex][vertex.index]) *\n        progressionsPhaseScope[activePhaseIndex][vertex.index];\n    var result = factor * maxLength;\n    return result;\n};\nvar phaseThree = {\n    duration: function () { return 0.5; },\n    progressionsPhaseScope: progressionsPhaseScope,\n    progressionsGeneralScope: progressionsGeneralScope,\n    groupsParameters: [\n        {\n            incircle: function () { return false; },\n            type: function () { return \"radial\"; },\n            radius: function (_a) {\n                var vertex = _a.vertex;\n                return vertex.length;\n            },\n            adaptArms: function () { return true; },\n            round: roundFirstGroup,\n            lengthBasedRound: function () { return true; }\n        },\n        {\n            incircle: function () { return false; },\n            type: function () { return \"linear\"; },\n            radius: radiusSecondGroup,\n            adaptArms: function () { return false; },\n            round: function () { return 1; },\n            lengthBasedRound: function () { return true; }\n        }\n    ]\n};\nexports.default = {\n    loop: undefined,\n    startGroupsParameters: startGroupsParameters,\n    endGroupsParameters: endGroupsParameters,\n    baseParameters: baseParameters,\n    phases: [__assign({}, phaseOne), __assign({}, phaseTwo), __assign({}, phaseThree)]\n};\n"]},"metadata":{},"sourceType":"script"}