{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar parseGroupParameterReducer_1 = __importDefault(require(\"./parseGroupParameterReducer\"));\n\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\n\nvar misc_1 = require(\"../../misc\"); // Logging\n\n\nvar log = require(\"loglevel\").getLogger(\"path-log\");\n\nvar getRoundValue = function (group, vertexIndex) {\n  /* Get round value for a vertex from given group parameters */\n  var value = group.round;\n  value = parseGroupParameterReducer_1.default(\"round\", value, vertexIndex);\n  if (typeof value !== \"object\" || value.length !== 2) throw \"Wrong 'round' value in group number \" + group.pk + \". Round: \" + value;else return value;\n};\n\nvar getDistanceValue = function (group, vertexIndex) {\n  /* Get distance value for a vertex from given group parameters */\n  var parameter = group.distance;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (typeof parameter !== \"number\") throw \"Wrong 'distance' parameters in group number \" + group.pk;else return parameter;\n};\n\nvar getRadiusValue = function (group, vertexIndex) {\n  /* Get radius value for a vertex from given group parameters */\n  var parameter = group.radius;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"number\") throw \"Wrong 'radius' parameters in group number \" + group.pk;else return parameter;\n};\n\nvar generateLinearVertexCoordinates = function (vertexes, vertex, prevVertex, nextVertex) {\n  // Calc X Y coords\n  vertex.x = prevVertex.x - nextVertex.x; // Substract adjacent points to get x\n\n  vertex.x *= 0.5; // Make x twice closer to center\n\n  vertex.x += nextVertex.x; // Position x inbetween of adjacent points\n\n  vertex.y = prevVertex.y - nextVertex.y; // Make the same with Y\n\n  vertex.y *= 0.5;\n  vertex.y += nextVertex.y;\n  vertex.radians = Math.atan2(vertex.y, vertex.x);\n  vertex.angle = misc_1.radToAngle(vertex.radians);\n  return vertex;\n};\n\nvar getTypeValue = function (group, vertexIndex) {\n  var parameter = group.type;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"string\") throw \"Wrong 'type' parameter in group number \" + group.pk;else return parameter;\n};\n\nvar generateRadialVertexCoordinates = function (vertexes, vertex, prevVertex, nextVertex) {\n  var radiansStep = misc_1.radiansDelta(nextVertex.radians, prevVertex.radians) / 2;\n  vertex.radians = prevVertex.radians + radiansStep;\n  vertex.cosx = misc_1.round(Math.cos(vertex.radians));\n  vertex.siny = misc_1.round(Math.sin(vertex.radians));\n  vertex.x = vertex.cosx;\n  vertex.y = vertex.siny;\n  return vertex;\n};\n\nvar generateVertexes = function (path) {\n  log.info(\"generate vertexes\");\n  var frame = path.frame;\n  var _a = path.parameters,\n      numOfGroups = _a.numOfGroups,\n      numOfSegments = _a.numOfSegments,\n      groups = _a.groups;\n  var subdivisionDepth = numOfGroups - 1;\n  var numOfPoints = numOfSegments * Math.pow(2, subdivisionDepth);\n  var numOfVertexesPerSide = numOfPoints / frame.numOfVertexes; // Init root group from frame vertexes\n\n  groups[0].numOfVertexes = frame.numOfVertexes;\n  groups[0].pk = 0;\n  var vertexes = frame.vertexes.map(function (vertex, index) {\n    return __assign({}, vertex, {\n      type: \"C\",\n      indexWithingGroup: index,\n      group: 0,\n      round: getRoundValue(groups[0], index),\n      distance: getDistanceValue(groups[0], index),\n      radius: getRadiusValue(groups[0], index)\n    });\n  });\n\n  for (var groupIndex = 1; groupIndex < numOfGroups; groupIndex++) {\n    log.debug(\"group number\", groupIndex);\n    var numOfNewVertexes = vertexes.length;\n    log.debug(\"number of vertexes\", numOfNewVertexes);\n    groups[groupIndex].numOfVertexes = numOfNewVertexes;\n    groups[groupIndex].pk = groupIndex;\n\n    for (var i = 1; i < numOfNewVertexes * 2; i += 2) {\n      var indexWithingGroup = (i - 1) / 2;\n      var protoVertex = {\n        type: \"C\",\n        group: groupIndex\n      };\n      vertexes.splice(i, 0, protoVertex); // Inser proto vertex in array\n\n      var lastIndex = vertexes.length - 1;\n      var prevVertexInd = i - 1;\n      var nextVertexInd = i + 1;\n      if (nextVertexInd > lastIndex) nextVertexInd = 0;\n      var vertex = vertexes[i];\n      var prevVertex = vertexes[prevVertexInd];\n      var nextVertex = vertexes[nextVertexInd];\n      var vertexType = getTypeValue(groups[groupIndex], indexWithingGroup);\n\n      switch (vertexType) {\n        case \"linear\":\n          vertex = generateLinearVertexCoordinates(vertexes, vertex, prevVertex, nextVertex);\n          break;\n\n        case \"radial\":\n          vertex = generateRadialVertexCoordinates(vertexes, vertex, prevVertex, nextVertex);\n          break;\n\n        default:\n          throw \"Type for group \" + groupIndex + \" seems to be wrong.\";\n          break;\n      } // Set distance, round, and radius values per vertex\n\n\n      log.debug(\"vertex index withing a group\", indexWithingGroup);\n      vertexes[i].distance = getDistanceValue(groups[groupIndex], indexWithingGroup);\n      vertexes[i].round = getRoundValue(groups[groupIndex], indexWithingGroup);\n      vertexes[i].radius = getRadiusValue(groups[groupIndex], indexWithingGroup);\n      vertexes[i].indexWithingGroup = indexWithingGroup;\n    }\n  }\n\n  path.vertexes = vertexes;\n  return path;\n};\n\nexports.default = generateVertexes;","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/path/lib/generateVertexes.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__importDefault","mod","__esModule","defineProperty","exports","value","parseGroupParameterReducer_1","require","parseGroupParameter_1","misc_1","log","getLogger","getRoundValue","group","vertexIndex","round","default","pk","getDistanceValue","parameter","distance","getRadiusValue","radius","generateLinearVertexCoordinates","vertexes","vertex","prevVertex","nextVertex","x","y","radians","Math","atan2","angle","radToAngle","getTypeValue","type","generateRadialVertexCoordinates","radiansStep","radiansDelta","cosx","cos","siny","sin","generateVertexes","path","info","frame","_a","parameters","numOfGroups","numOfSegments","groups","subdivisionDepth","numOfPoints","pow","numOfVertexesPerSide","numOfVertexes","map","index","indexWithingGroup","groupIndex","debug","numOfNewVertexes","protoVertex","splice","lastIndex","prevVertexInd","nextVertexInd","vertexType"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parseGroupParameterReducer_1 = __importDefault(require(\"./parseGroupParameterReducer\"));\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\nvar misc_1 = require(\"../../misc\");\n// Logging\nvar log = require(\"loglevel\").getLogger(\"path-log\");\nvar getRoundValue = function (group, vertexIndex) {\n    /* Get round value for a vertex from given group parameters */\n    var value = group.round;\n    value = parseGroupParameterReducer_1.default(\"round\", value, vertexIndex);\n    if (typeof value !== \"object\" || value.length !== 2)\n        throw \"Wrong 'round' value in group number \" + group.pk + \". Round: \" + value;\n    else\n        return value;\n};\nvar getDistanceValue = function (group, vertexIndex) {\n    /* Get distance value for a vertex from given group parameters */\n    var parameter = group.distance;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (typeof parameter !== \"number\")\n        throw \"Wrong 'distance' parameters in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar getRadiusValue = function (group, vertexIndex) {\n    /* Get radius value for a vertex from given group parameters */\n    var parameter = group.radius;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"number\")\n        throw \"Wrong 'radius' parameters in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar generateLinearVertexCoordinates = function (vertexes, vertex, prevVertex, nextVertex) {\n    // Calc X Y coords\n    vertex.x = prevVertex.x - nextVertex.x; // Substract adjacent points to get x\n    vertex.x *= 0.5; // Make x twice closer to center\n    vertex.x += nextVertex.x; // Position x inbetween of adjacent points\n    vertex.y = prevVertex.y - nextVertex.y; // Make the same with Y\n    vertex.y *= 0.5;\n    vertex.y += nextVertex.y;\n    vertex.radians = Math.atan2(vertex.y, vertex.x);\n    vertex.angle = misc_1.radToAngle(vertex.radians);\n    return vertex;\n};\nvar getTypeValue = function (group, vertexIndex) {\n    var parameter = group.type;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"string\")\n        throw \"Wrong 'type' parameter in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar generateRadialVertexCoordinates = function (vertexes, vertex, prevVertex, nextVertex) {\n    var radiansStep = misc_1.radiansDelta(nextVertex.radians, prevVertex.radians) / 2;\n    vertex.radians = prevVertex.radians + radiansStep;\n    vertex.cosx = misc_1.round(Math.cos(vertex.radians));\n    vertex.siny = misc_1.round(Math.sin(vertex.radians));\n    vertex.x = vertex.cosx;\n    vertex.y = vertex.siny;\n    return vertex;\n};\nvar generateVertexes = function (path) {\n    log.info(\"generate vertexes\");\n    var frame = path.frame;\n    var _a = path.parameters, numOfGroups = _a.numOfGroups, numOfSegments = _a.numOfSegments, groups = _a.groups;\n    var subdivisionDepth = numOfGroups - 1;\n    var numOfPoints = numOfSegments * Math.pow(2, subdivisionDepth);\n    var numOfVertexesPerSide = numOfPoints / frame.numOfVertexes;\n    // Init root group from frame vertexes\n    groups[0].numOfVertexes = frame.numOfVertexes;\n    groups[0].pk = 0;\n    var vertexes = frame.vertexes.map(function (vertex, index) { return (__assign({}, vertex, { type: \"C\", indexWithingGroup: index, group: 0, round: getRoundValue(groups[0], index), distance: getDistanceValue(groups[0], index), radius: getRadiusValue(groups[0], index) })); });\n    for (var groupIndex = 1; groupIndex < numOfGroups; groupIndex++) {\n        log.debug(\"group number\", groupIndex);\n        var numOfNewVertexes = vertexes.length;\n        log.debug(\"number of vertexes\", numOfNewVertexes);\n        groups[groupIndex].numOfVertexes = numOfNewVertexes;\n        groups[groupIndex].pk = groupIndex;\n        for (var i = 1; i < numOfNewVertexes * 2; i += 2) {\n            var indexWithingGroup = (i - 1) / 2;\n            var protoVertex = {\n                type: \"C\",\n                group: groupIndex\n            };\n            vertexes.splice(i, 0, protoVertex); // Inser proto vertex in array\n            var lastIndex = vertexes.length - 1;\n            var prevVertexInd = i - 1;\n            var nextVertexInd = i + 1;\n            if (nextVertexInd > lastIndex)\n                nextVertexInd = 0;\n            var vertex = vertexes[i];\n            var prevVertex = vertexes[prevVertexInd];\n            var nextVertex = vertexes[nextVertexInd];\n            var vertexType = getTypeValue(groups[groupIndex], indexWithingGroup);\n            switch (vertexType) {\n                case \"linear\":\n                    vertex = generateLinearVertexCoordinates(vertexes, vertex, prevVertex, nextVertex);\n                    break;\n                case \"radial\":\n                    vertex = generateRadialVertexCoordinates(vertexes, vertex, prevVertex, nextVertex);\n                    break;\n                default:\n                    throw \"Type for group \" + groupIndex + \" seems to be wrong.\";\n                    break;\n            }\n            // Set distance, round, and radius values per vertex\n            log.debug(\"vertex index withing a group\", indexWithingGroup);\n            vertexes[i].distance = getDistanceValue(groups[groupIndex], indexWithingGroup);\n            vertexes[i].round = getRoundValue(groups[groupIndex], indexWithingGroup);\n            vertexes[i].radius = getRadiusValue(groups[groupIndex], indexWithingGroup);\n            vertexes[i].indexWithingGroup = indexWithingGroup;\n        }\n    }\n    path.vertexes = vertexes;\n    return path;\n};\nexports.default = generateVertexes;\n"]},"metadata":{},"sourceType":"script"}