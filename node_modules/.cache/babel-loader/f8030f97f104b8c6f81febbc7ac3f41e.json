{"ast":null,"code":"\"use strict\";\n/**\n * @since 2.0.0\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @since 2.0.0\n */\n\nfunction identity(a) {\n  return a;\n}\n\nexports.identity = identity;\n/**\n * @since 2.0.0\n */\n\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\n\nfunction not(predicate) {\n  return function (a) {\n    return !predicate(a);\n  };\n}\n\nexports.not = not;\n/**\n * @since 2.0.0\n */\n\nfunction constant(a) {\n  return function () {\n    return a;\n  };\n}\n\nexports.constant = constant;\n/**\n * A thunk that returns always `true`\n *\n * @since 2.0.0\n */\n\nexports.constTrue = function () {\n  return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 2.0.0\n */\n\n\nexports.constFalse = function () {\n  return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 2.0.0\n */\n\n\nexports.constNull = function () {\n  return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 2.0.0\n */\n\n\nexports.constUndefined = function () {\n  return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 2.0.0\n */\n\n\nexports.constVoid = function () {\n  return;\n};\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\n\n\nfunction flip(f) {\n  return function (b, a) {\n    return f(a, b);\n  };\n}\n\nexports.flip = flip;\n\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n\n  return;\n}\n\nexports.flow = flow;\n/**\n * @since 2.0.0\n */\n\nfunction tuple() {\n  var t = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    t[_i] = arguments[_i];\n  }\n\n  return t;\n}\n\nexports.tuple = tuple;\n/**\n * @since 2.0.0\n */\n\nfunction increment(n) {\n  return n + 1;\n}\n\nexports.increment = increment;\n/**\n * @since 2.0.0\n */\n\nfunction decrement(n) {\n  return n - 1;\n}\n\nexports.decrement = decrement;\n/**\n * @since 2.0.0\n */\n\nfunction absurd(_) {\n  throw new Error('Called `absurd` function which should be uncallable');\n}\n\nexports.absurd = absurd;\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/lib/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\n\nfunction tupled(f) {\n  return function (a) {\n    return f.apply(void 0, a);\n  };\n}\n\nexports.tupled = tupled;\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\n\nfunction untupled(f) {\n  return function () {\n    var a = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      a[_i] = arguments[_i];\n    }\n\n    return f(a);\n  };\n}\n\nexports.untupled = untupled;","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/fp-ts/lib/function.js"],"names":["Object","defineProperty","exports","value","identity","a","unsafeCoerce","not","predicate","constant","constTrue","constFalse","constNull","constUndefined","constVoid","flip","f","b","flow","ab","bc","cd","de","ef","fg","gh","hi","ij","arguments","length","apply","tuple","t","_i","increment","n","decrement","absurd","_","Error","tupled","untupled"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * @since 2.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\nexports.identity = identity;\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\nexports.not = not;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\nexports.constant = constant;\n/**\n * A thunk that returns always `true`\n *\n * @since 2.0.0\n */\nexports.constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 2.0.0\n */\nexports.constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 2.0.0\n */\nexports.constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 2.0.0\n */\nexports.constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 2.0.0\n */\nexports.constVoid = function () {\n    return;\n};\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nfunction flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexports.flip = flip;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\nexports.flow = flow;\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\nexports.tuple = tuple;\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\nexports.increment = increment;\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\nexports.decrement = decrement;\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/lib/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\nexports.tupled = tupled;\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexports.untupled = untupled;\n"]},"metadata":{},"sourceType":"script"}