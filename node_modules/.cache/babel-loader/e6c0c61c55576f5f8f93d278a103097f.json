{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\n\nvar misc_1 = require(\"../../misc\");\n\nvar getIncircleValue = function (group, vertexIndex) {\n  var parameter = group.incircle;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"boolean\") throw \"Wrong 'incircle' parameter in group number \" + group.pk;else return parameter;\n};\n\nvar scaleToOne = function (path) {\n  var groups = path.parameters.groups;\n  var needToScale;\n\n  for (var index = 0; index < groups.length; index++) {\n    // Check settings if it needs to scale\n    if (groups[index].incircle) {\n      if (misc_1.getType(groups[index].incircle) === \"array\") {\n        // Incircle is an array. Try to scale\n        needToScale = true;\n        break;\n      }\n    } else {\n      needToScale = true;\n      break;\n    }\n  }\n\n  if (!needToScale) // Incircle value is true. Cancel scale and return path as it is.\n    return path;\n  var maxX = 0;\n  var minX = 0;\n  var maxY = 0;\n  var minY = 0;\n  path.vertexes.forEach(function (vertex) {\n    if (vertex.x > maxX) maxX = vertex.x;\n    if (vertex.x < minX) minX = vertex.x;\n    if (vertex.y > maxY) maxY = vertex.y;\n    if (vertex.y < minY) minY = vertex.y;\n  });\n  var factorX = 2 / (Math.abs(minX) + maxX);\n  var factorY = 2 / (Math.abs(minY) + maxY);\n  var shiftX = factorX * maxX - 1;\n  var shiftY = factorY * maxY - 1;\n  path.vertexes = path.vertexes.map(function (vertex, index) {\n    var incircleValue = getIncircleValue(groups[vertex.group], vertex.indexWithingGroup);\n\n    if (!incircleValue) {\n      vertex.x = vertex.x * factorX - shiftX;\n      vertex.y = vertex.y * factorY - shiftY;\n    }\n\n    if (vertex.type === \"C\") {\n      var incircleFirstArmValue = getIncircleValue(groups[path.vertexes[index - 1].group], path.vertexes[index - 1].indexWithingGroup);\n\n      if (!incircleFirstArmValue) {\n        vertex.x1 = vertex.x1 * factorX - shiftX;\n        vertex.y1 = vertex.y1 * factorY - shiftY;\n      }\n\n      if (!incircleValue) {\n        vertex.x2 = vertex.x2 * factorX - shiftX;\n        vertex.y2 = vertex.y2 * factorY - shiftY;\n      }\n    }\n\n    return vertex;\n  });\n  return path;\n};\n\nexports.default = scaleToOne;","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/path/lib/scaleToOne.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","parseGroupParameter_1","require","misc_1","getIncircleValue","group","vertexIndex","parameter","incircle","default","pk","scaleToOne","path","groups","parameters","needToScale","index","length","getType","maxX","minX","maxY","minY","vertexes","forEach","vertex","x","y","factorX","Math","abs","factorY","shiftX","shiftY","map","incircleValue","indexWithingGroup","type","incircleFirstArmValue","x1","y1","x2","y2"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\nvar misc_1 = require(\"../../misc\");\nvar getIncircleValue = function (group, vertexIndex) {\n    var parameter = group.incircle;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"boolean\")\n        throw \"Wrong 'incircle' parameter in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar scaleToOne = function (path) {\n    var groups = path.parameters.groups;\n    var needToScale;\n    for (var index = 0; index < groups.length; index++) {\n        // Check settings if it needs to scale\n        if (groups[index].incircle) {\n            if (misc_1.getType(groups[index].incircle) === \"array\") {\n                // Incircle is an array. Try to scale\n                needToScale = true;\n                break;\n            }\n        }\n        else {\n            needToScale = true;\n            break;\n        }\n    }\n    if (!needToScale)\n        // Incircle value is true. Cancel scale and return path as it is.\n        return path;\n    var maxX = 0;\n    var minX = 0;\n    var maxY = 0;\n    var minY = 0;\n    path.vertexes.forEach(function (vertex) {\n        if (vertex.x > maxX)\n            maxX = vertex.x;\n        if (vertex.x < minX)\n            minX = vertex.x;\n        if (vertex.y > maxY)\n            maxY = vertex.y;\n        if (vertex.y < minY)\n            minY = vertex.y;\n    });\n    var factorX = 2 / (Math.abs(minX) + maxX);\n    var factorY = 2 / (Math.abs(minY) + maxY);\n    var shiftX = factorX * maxX - 1;\n    var shiftY = factorY * maxY - 1;\n    path.vertexes = path.vertexes.map(function (vertex, index) {\n        var incircleValue = getIncircleValue(groups[vertex.group], vertex.indexWithingGroup);\n        if (!incircleValue) {\n            vertex.x = vertex.x * factorX - shiftX;\n            vertex.y = vertex.y * factorY - shiftY;\n        }\n        if (vertex.type === \"C\") {\n            var incircleFirstArmValue = getIncircleValue(groups[path.vertexes[index - 1].group], path.vertexes[index - 1].indexWithingGroup);\n            if (!incircleFirstArmValue) {\n                vertex.x1 = vertex.x1 * factorX - shiftX;\n                vertex.y1 = vertex.y1 * factorY - shiftY;\n            }\n            if (!incircleValue) {\n                vertex.x2 = vertex.x2 * factorX - shiftX;\n                vertex.y2 = vertex.y2 * factorY - shiftY;\n            }\n        }\n        return vertex;\n    });\n    return path;\n};\nexports.default = scaleToOne;\n"]},"metadata":{},"sourceType":"script"}