{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\n\nvar misc_1 = require(\"../../misc\");\n\nvar ramda_1 = require(\"ramda\"); // logging\n\n\nvar log = require(\"loglevel\").getLogger(\"path-log\");\n\nvar getAdaptArmsValue = function (group, vertexIndex) {\n  var parameter = group.adaptArms;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"boolean\") throw \"Wrong 'adaptArms' parameter in group number \" + group.pk;else return parameter;\n};\n\nvar getSmartRoundValue = function (group, vertexIndex) {\n  var parameter = group.smartRound;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"boolean\") throw \"Wrong 'smartRound' parameter in group number \" + group.pk;else return parameter;\n};\n\nvar getLengthBasedRoundValue = function (group, vertexIndex) {\n  var parameter = group.lengthBasedRound;\n  parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n  if (!parameter) return parameter;else if (typeof parameter !== \"boolean\") throw \"Wrong 'lengthBasedRound' parameter in group number \" + group.pk;else return parameter;\n};\n\nvar setArms = function (mode, path) {\n  var vertexes = path.vertexes;\n  var _a = path.parameters,\n      groups = _a.groups,\n      averageLength = _a.averageLength;\n  var numOfPoints = vertexes.length - 1; // Minus \"M\" vertex\n\n  var averageLength;\n\n  for (var i = 1; i < vertexes.length; i++) {\n    // Adapt arms\n    var firstArmAdapt = getAdaptArmsValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n    var secondArmAdapt = getAdaptArmsValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup);\n    if (mode === \"init\" && firstArmAdapt && secondArmAdapt) continue;else if (mode === \"adapt\" && !firstArmAdapt && !secondArmAdapt) continue; // Prepare vars\n\n    var firstArmLength = void 0,\n        secondArmLength = void 0; // Smart round\n\n    var firstArmSmartRound = getSmartRoundValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n    var secondArmSmartRound = getSmartRoundValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup); // Length based round\n\n    var firstArmLengthBasedRound = getLengthBasedRoundValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n    var secondArmLengthBasedRound = getLengthBasedRoundValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup); // Calc individual factor for smart round\n\n    var individualFactor = void 0;\n\n    if (firstArmSmartRound || secondArmSmartRound) {\n      var distanceRadians = misc_1.radiansDelta(vertexes[i - 1].radians, vertexes[i].radians);\n      individualFactor = 2 * Math.PI / distanceRadians;\n    } // First arm\n\n\n    if (mode === \"adapt\" && firstArmAdapt || mode === \"init\" && !firstArmAdapt) {\n      // Calc first arm\n      log.info(\"calc first arm. Mode: \" + mode);\n      var firstArmFactor = firstArmSmartRound ? individualFactor : numOfPoints;\n      firstArmLength = 4 / 3 * Math.tan(Math.PI / (2 * firstArmFactor));\n\n      if (mode === \"adapt\") {\n        // Set scale\n        var firstArmScaleFactor = firstArmLengthBasedRound ? vertexes[i - 1].length : averageLength;\n        firstArmLength *= firstArmScaleFactor;\n      } // Round\n\n\n      firstArmLength *= vertexes[i - 1].round[1]; // Set angle\n\n      var firstArmRadians = vertexes[i - 1].radians + Math.PI / 2; // angle + 90 from the previous point angle\n\n      var firstArmAngle = misc_1.radToAngle(firstArmRadians);\n      log.debug(\"first arm angle\", firstArmAngle); // Set cos and sin\n\n      var cosx1 = misc_1.round(Math.cos(firstArmRadians));\n      if (mode === \"adapt\") cosx1 *= -1;\n      var siny1 = misc_1.round(Math.sin(firstArmRadians)); // Set coordinates\n\n      var x1 = cosx1 * firstArmLength + vertexes[i - 1].x;\n      var y1 = siny1 * firstArmLength + vertexes[i - 1].y;\n      log.debug(\"vertex \" + i + \" first arm x: \" + x1 + \" y: \" + y1); // Add to vertex\n\n      vertexes[i] = __assign({}, vertexes[i], {\n        x1: x1,\n        y1: y1,\n        cosx1: cosx1,\n        siny1: siny1\n      });\n    } // Second arm\n\n\n    if (mode === \"adapt\" && secondArmAdapt || mode === \"init\" && !secondArmAdapt) {\n      // Calc second arm\n      log.info(\"calc second arm. Mode: \" + mode);\n      var secondArmFactor = secondArmSmartRound ? individualFactor : numOfPoints;\n      secondArmLength = 4 / 3 * Math.tan(Math.PI / (2 * secondArmFactor));\n\n      if (mode === \"adapt\") {\n        // Set scale\n        var secondArmScaleFactor = secondArmLengthBasedRound ? vertexes[i].length : averageLength;\n        secondArmLength *= secondArmScaleFactor;\n      } // Set round\n\n\n      secondArmLength *= vertexes[i].round[0]; // Set angle\n\n      var secondArmRadians = vertexes[i].radians - Math.PI / 2; // angle + 90 from cur point\n\n      var secondArmAngle = misc_1.radToAngle(secondArmRadians);\n      log.debug(\"second arm angle\", secondArmAngle); // Set cos and sin\n\n      var cosx2 = misc_1.round(Math.cos(secondArmRadians));\n      if (mode === \"adapt\") cosx2 *= -1;\n      var siny2 = misc_1.round(Math.sin(secondArmRadians)); // Set coordinates\n\n      var x2 = cosx2 * secondArmLength + vertexes[i].x;\n      var y2 = siny2 * secondArmLength + vertexes[i].y;\n      log.debug(\"vertex \" + i + \" second arm x: \" + x2 + \" y: \" + y2); // Add to vertex\n\n      vertexes[i] = __assign({}, vertexes[i], {\n        x2: x2,\n        y2: y2,\n        cosx2: cosx2,\n        siny2: siny2\n      });\n    }\n  }\n\n  return path;\n};\n\nexports.default = ramda_1.curry(setArms);","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/path/lib/setArms.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__importDefault","mod","__esModule","defineProperty","exports","value","parseGroupParameter_1","require","misc_1","ramda_1","log","getLogger","getAdaptArmsValue","group","vertexIndex","parameter","adaptArms","default","pk","getSmartRoundValue","smartRound","getLengthBasedRoundValue","lengthBasedRound","setArms","mode","path","vertexes","_a","parameters","groups","averageLength","numOfPoints","firstArmAdapt","indexWithingGroup","secondArmAdapt","firstArmLength","secondArmLength","firstArmSmartRound","secondArmSmartRound","firstArmLengthBasedRound","secondArmLengthBasedRound","individualFactor","distanceRadians","radiansDelta","radians","Math","PI","info","firstArmFactor","tan","firstArmScaleFactor","round","firstArmRadians","firstArmAngle","radToAngle","debug","cosx1","cos","siny1","sin","x1","x","y1","y","secondArmFactor","secondArmScaleFactor","secondArmRadians","secondArmAngle","cosx2","siny2","x2","y2","curry"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parseGroupParameter_1 = __importDefault(require(\"./parseGroupParameter\"));\nvar misc_1 = require(\"../../misc\");\nvar ramda_1 = require(\"ramda\");\n// logging\nvar log = require(\"loglevel\").getLogger(\"path-log\");\nvar getAdaptArmsValue = function (group, vertexIndex) {\n    var parameter = group.adaptArms;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"boolean\")\n        throw \"Wrong 'adaptArms' parameter in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar getSmartRoundValue = function (group, vertexIndex) {\n    var parameter = group.smartRound;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"boolean\")\n        throw \"Wrong 'smartRound' parameter in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar getLengthBasedRoundValue = function (group, vertexIndex) {\n    var parameter = group.lengthBasedRound;\n    parameter = parseGroupParameter_1.default(parameter, vertexIndex);\n    if (!parameter)\n        return parameter;\n    else if (typeof parameter !== \"boolean\")\n        throw \"Wrong 'lengthBasedRound' parameter in group number \" + group.pk;\n    else\n        return parameter;\n};\nvar setArms = function (mode, path) {\n    var vertexes = path.vertexes;\n    var _a = path.parameters, groups = _a.groups, averageLength = _a.averageLength;\n    var numOfPoints = vertexes.length - 1; // Minus \"M\" vertex\n    var averageLength;\n    for (var i = 1; i < vertexes.length; i++) {\n        // Adapt arms\n        var firstArmAdapt = getAdaptArmsValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n        var secondArmAdapt = getAdaptArmsValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup);\n        if (mode === \"init\" && firstArmAdapt && secondArmAdapt)\n            continue;\n        else if (mode === \"adapt\" && !firstArmAdapt && !secondArmAdapt)\n            continue;\n        // Prepare vars\n        var firstArmLength = void 0, secondArmLength = void 0;\n        // Smart round\n        var firstArmSmartRound = getSmartRoundValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n        var secondArmSmartRound = getSmartRoundValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup);\n        // Length based round\n        var firstArmLengthBasedRound = getLengthBasedRoundValue(groups[vertexes[i - 1].group], vertexes[i - 1].indexWithingGroup);\n        var secondArmLengthBasedRound = getLengthBasedRoundValue(groups[vertexes[i].group], vertexes[i].indexWithingGroup);\n        // Calc individual factor for smart round\n        var individualFactor = void 0;\n        if (firstArmSmartRound || secondArmSmartRound) {\n            var distanceRadians = misc_1.radiansDelta(vertexes[i - 1].radians, vertexes[i].radians);\n            individualFactor = (2 * Math.PI) / distanceRadians;\n        }\n        // First arm\n        if ((mode === \"adapt\" && firstArmAdapt) ||\n            (mode === \"init\" && !firstArmAdapt)) {\n            // Calc first arm\n            log.info(\"calc first arm. Mode: \" + mode);\n            var firstArmFactor = firstArmSmartRound ? individualFactor : numOfPoints;\n            firstArmLength = (4 / 3) * Math.tan(Math.PI / (2 * firstArmFactor));\n            if (mode === \"adapt\") {\n                // Set scale\n                var firstArmScaleFactor = firstArmLengthBasedRound\n                    ? vertexes[i - 1].length\n                    : averageLength;\n                firstArmLength *= firstArmScaleFactor;\n            }\n            // Round\n            firstArmLength *= vertexes[i - 1].round[1];\n            // Set angle\n            var firstArmRadians = vertexes[i - 1].radians + Math.PI / 2; // angle + 90 from the previous point angle\n            var firstArmAngle = misc_1.radToAngle(firstArmRadians);\n            log.debug(\"first arm angle\", firstArmAngle);\n            // Set cos and sin\n            var cosx1 = misc_1.round(Math.cos(firstArmRadians));\n            if (mode === \"adapt\")\n                cosx1 *= -1;\n            var siny1 = misc_1.round(Math.sin(firstArmRadians));\n            // Set coordinates\n            var x1 = cosx1 * firstArmLength + vertexes[i - 1].x;\n            var y1 = siny1 * firstArmLength + vertexes[i - 1].y;\n            log.debug(\"vertex \" + i + \" first arm x: \" + x1 + \" y: \" + y1);\n            // Add to vertex\n            vertexes[i] = __assign({}, vertexes[i], { x1: x1,\n                y1: y1,\n                cosx1: cosx1,\n                siny1: siny1 });\n        }\n        // Second arm\n        if ((mode === \"adapt\" && secondArmAdapt) ||\n            (mode === \"init\" && !secondArmAdapt)) {\n            // Calc second arm\n            log.info(\"calc second arm. Mode: \" + mode);\n            var secondArmFactor = secondArmSmartRound\n                ? individualFactor\n                : numOfPoints;\n            secondArmLength = (4 / 3) * Math.tan(Math.PI / (2 * secondArmFactor));\n            if (mode === \"adapt\") {\n                // Set scale\n                var secondArmScaleFactor = secondArmLengthBasedRound\n                    ? vertexes[i].length\n                    : averageLength;\n                secondArmLength *= secondArmScaleFactor;\n            }\n            // Set round\n            secondArmLength *= vertexes[i].round[0];\n            // Set angle\n            var secondArmRadians = vertexes[i].radians - Math.PI / 2; // angle + 90 from cur point\n            var secondArmAngle = misc_1.radToAngle(secondArmRadians);\n            log.debug(\"second arm angle\", secondArmAngle);\n            // Set cos and sin\n            var cosx2 = misc_1.round(Math.cos(secondArmRadians));\n            if (mode === \"adapt\")\n                cosx2 *= -1;\n            var siny2 = misc_1.round(Math.sin(secondArmRadians));\n            // Set coordinates\n            var x2 = cosx2 * secondArmLength + vertexes[i].x;\n            var y2 = siny2 * secondArmLength + vertexes[i].y;\n            log.debug(\"vertex \" + i + \" second arm x: \" + x2 + \" y: \" + y2);\n            // Add to vertex\n            vertexes[i] = __assign({}, vertexes[i], { x2: x2,\n                y2: y2,\n                cosx2: cosx2,\n                siny2: siny2 });\n        }\n    }\n    return path;\n};\nexports.default = ramda_1.curry(setArms);\n"]},"metadata":{},"sourceType":"script"}