{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\n\nvar generateGroupsParameters = function (data) {\n  // Set groups parameters for each progression and each vertex\n  var endPath = data.endPath,\n      startPath = data.startPath,\n      progressions = data.progressions,\n      progressionsGeneralScope = data.progressionsGeneralScope,\n      progressionsPhaseScope = data.progressionsPhaseScope;\n  var phases = data.parameters.phases;\n  var numOfPhases = phases.length;\n  var pathsGroupsParameters = Array(progressions.length);\n\n  var _loop_1 = function (prIndex) {\n    pathsGroupsParameters[prIndex] = [];\n    endPath.vertexes.forEach(function (vertex, vIndex) {\n      var gIndex = vertex.group;\n      var indexWithingGroup = vertex.indexWithingGroup; // loop vertexes\n\n      var activePhaseIndex;\n      var keyVertexIndex;\n\n      for (var phIndex = 0; phIndex < numOfPhases; phIndex++) {\n        // loop phases and pick first incomplete phase to take values from\n        // Check if current phase is incomplete\n        var phaseIsIncomplete = progressions[prIndex] <= progressionsGeneralScope[phIndex][vIndex];\n\n        if (phaseIsIncomplete) {\n          // Current phase is the one we need. Break phases loop.\n          var groupsParameters = phases[phIndex].groupsParameters;\n          activePhaseIndex = phIndex;\n          break;\n        }\n      }\n\n      if (pathsGroupsParameters[prIndex][gIndex] === undefined) pathsGroupsParameters[prIndex][gIndex] = {};\n      var parametersSource = // If activePhaseIndex is undefined set previous progression values as a source\n      activePhaseIndex === undefined ? pathsGroupsParameters[prIndex - 1][gIndex] : phases[activePhaseIndex].groupsParameters[gIndex];\n\n      for (var _i = 0, _a = Object.entries(parametersSource); _i < _a.length; _i++) {\n        var _b = _a[_i],\n            key = _b[0],\n            source = _b[1]; // loop group param methods and take values\n\n        var value = // If activePhaseIndex is undefined take value from previus progression\n        activePhaseIndex === undefined ? source[indexWithingGroup] : source({\n          startPath: startPath,\n          endPath: endPath,\n          vertex: vertex,\n          progression: progressions[prIndex],\n          activePhaseIndex: activePhaseIndex,\n          progressionsGeneralScope: progressionsGeneralScope,\n          progressionsPhaseScope: progressionsPhaseScope\n        });\n        if (pathsGroupsParameters[prIndex][gIndex][key] === undefined) pathsGroupsParameters[prIndex][gIndex][key] = [];\n        pathsGroupsParameters[prIndex][gIndex][key][indexWithingGroup] = value;\n      }\n    });\n  };\n\n  for (var prIndex = 0; prIndex < progressions.length; prIndex++) {\n    _loop_1(prIndex);\n  }\n\n  log.debug(\"paths groups parameters\", pathsGroupsParameters);\n  return __assign({}, data, {\n    pathsGroupsParameters: pathsGroupsParameters\n  });\n};\n\nexports.default = generateGroupsParameters;","map":{"version":3,"sources":["/home/jannat/Drive/Projects/React native/Reacts/animator/node_modules/primitivo-svg/build/phases/lib/generateGroupsParameters.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","defineProperty","exports","value","log","require","getLogger","generateGroupsParameters","data","endPath","startPath","progressions","progressionsGeneralScope","progressionsPhaseScope","phases","parameters","numOfPhases","pathsGroupsParameters","Array","_loop_1","prIndex","vertexes","forEach","vertex","vIndex","gIndex","group","indexWithingGroup","activePhaseIndex","keyVertexIndex","phIndex","phaseIsIncomplete","groupsParameters","undefined","parametersSource","_i","_a","entries","_b","key","source","progression","debug","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log = require(\"loglevel\").getLogger(\"phases-log\");\nvar generateGroupsParameters = function (data) {\n    // Set groups parameters for each progression and each vertex\n    var endPath = data.endPath, startPath = data.startPath, progressions = data.progressions, progressionsGeneralScope = data.progressionsGeneralScope, progressionsPhaseScope = data.progressionsPhaseScope;\n    var phases = data.parameters.phases;\n    var numOfPhases = phases.length;\n    var pathsGroupsParameters = Array(progressions.length);\n    var _loop_1 = function (prIndex) {\n        pathsGroupsParameters[prIndex] = [];\n        endPath.vertexes.forEach(function (vertex, vIndex) {\n            var gIndex = vertex.group;\n            var indexWithingGroup = vertex.indexWithingGroup;\n            // loop vertexes\n            var activePhaseIndex;\n            var keyVertexIndex;\n            for (var phIndex = 0; phIndex < numOfPhases; phIndex++) {\n                // loop phases and pick first incomplete phase to take values from\n                // Check if current phase is incomplete\n                var phaseIsIncomplete = progressions[prIndex] <= progressionsGeneralScope[phIndex][vIndex];\n                if (phaseIsIncomplete) {\n                    // Current phase is the one we need. Break phases loop.\n                    var groupsParameters = phases[phIndex].groupsParameters;\n                    activePhaseIndex = phIndex;\n                    break;\n                }\n            }\n            if (pathsGroupsParameters[prIndex][gIndex] === undefined)\n                pathsGroupsParameters[prIndex][gIndex] = {};\n            var parametersSource = \n            // If activePhaseIndex is undefined set previous progression values as a source\n            activePhaseIndex === undefined\n                ? pathsGroupsParameters[prIndex - 1][gIndex]\n                : phases[activePhaseIndex].groupsParameters[gIndex];\n            for (var _i = 0, _a = Object.entries(parametersSource); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], source = _b[1];\n                // loop group param methods and take values\n                var value = \n                // If activePhaseIndex is undefined take value from previus progression\n                activePhaseIndex === undefined\n                    ? source[indexWithingGroup]\n                    : source({\n                        startPath: startPath,\n                        endPath: endPath,\n                        vertex: vertex,\n                        progression: progressions[prIndex],\n                        activePhaseIndex: activePhaseIndex,\n                        progressionsGeneralScope: progressionsGeneralScope,\n                        progressionsPhaseScope: progressionsPhaseScope\n                    });\n                if (pathsGroupsParameters[prIndex][gIndex][key] === undefined)\n                    pathsGroupsParameters[prIndex][gIndex][key] = [];\n                pathsGroupsParameters[prIndex][gIndex][key][indexWithingGroup] = value;\n            }\n        });\n    };\n    for (var prIndex = 0; prIndex < progressions.length; prIndex++) {\n        _loop_1(prIndex);\n    }\n    log.debug(\"paths groups parameters\", pathsGroupsParameters);\n    return __assign({}, data, { pathsGroupsParameters: pathsGroupsParameters });\n};\nexports.default = generateGroupsParameters;\n"]},"metadata":{},"sourceType":"script"}